defmodule TradingDesk.ProductGroup.SeedExporter do
  @moduledoc """
  Exports current DB state of product group frames to the seed file.

  The seed file at `priv/repo/seeds/product_group_frames_seed.exs` serves as
  a persistent log of the current configuration. When an admin modifies product
  group configs, routes, constraints, or variables through the UI, this module
  regenerates the seed file so it always reflects the latest DB state.

  If the database ever needs to be reinitialized, running the seed file restores
  the last known-good configuration.

  ## Usage

      # Export all product groups to seed file
      SeedExporter.export!()

      # Export and get the generated source code as a string
      {:ok, source} = SeedExporter.export()
  """

  import Ecto.Query
  alias TradingDesk.Repo
  alias TradingDesk.DB.{ProductGroupConfig, RouteDefinition, ConstraintDefinition}
  alias TradingDesk.Variables.VariableDefinition

  @seed_path "priv/repo/seeds/product_group_frames_seed.exs"

  @doc "Export current DB state to seed file. Returns {:ok, source} or {:error, reason}."
  @spec export() :: {:ok, String.t()} | {:error, term()}
  def export do
    source = generate_seed_source()
    path = seed_path()

    case File.write(path, source) do
      :ok -> {:ok, source}
      {:error, reason} -> {:error, reason}
    end
  end

  @doc "Export current DB state to seed file. Raises on failure."
  @spec export!() :: :ok
  def export! do
    case export() do
      {:ok, _} -> :ok
      {:error, reason} -> raise "Failed to export seed: #{inspect(reason)}"
    end
  end

  @doc "Returns the absolute path to the seed file."
  @spec seed_path() :: String.t()
  def seed_path do
    case Application.get_env(:trading_desk, :seed_export_path) do
      nil -> @seed_path
      path -> path
    end
  end

  @doc "Generate the seed module source code from current DB state."
  @spec generate_seed_source() :: String.t()
  def generate_seed_source do
    configs = Repo.all(from c in ProductGroupConfig, where: c.active == true, order_by: c.key)
    timestamp = DateTime.utc_now() |> DateTime.to_iso8601()

    header = """
    defmodule TradingDesk.Seeds.ProductGroupFramesSeed do
      @moduledoc \"\"\"
      Seeds product_group_configs, route_definitions, constraint_definitions,
      and per-product-group variable_definitions from the database export.

      Auto-generated by SeedExporter at #{timestamp}.
      Idempotent — uses upsert on unique keys. Safe to re-run.
      \"\"\"

      alias TradingDesk.Repo
      alias TradingDesk.DB.{ProductGroupConfig, RouteDefinition, ConstraintDefinition}
      alias TradingDesk.Variables.VariableDefinition

      def run do
        IO.puts("  → Seeding product group frames (#{length(configs)} product groups)...")

    """

    body = Enum.map_join(configs, "\n", &generate_product_group/1)

    footer = """

        IO.puts("  ✓ Product group frames seeded")
      end

    #{generate_upsert_helpers()}
    end
    """

    header <> body <> footer
  end

  # ──────────────────────────────────────────────────────────
  # Code generation for each product group
  # ──────────────────────────────────────────────────────────

  defp generate_product_group(%ProductGroupConfig{} = c) do
    pg = c.key
    variables = load_variables(pg)
    routes = load_routes(pg)
    constraints = load_constraints(pg)

    """
        # ── #{c.name} (#{pg}) ──────────────────────────────────────
        IO.puts("    • #{pg} (#{c.name})")

        upsert_config(%{
    #{indent(format_config_attrs(c), 6)}
        })

    #{generate_variables(variables, pg)}
    #{generate_routes(routes, pg)}
    #{generate_constraints(constraints, pg)}
    """
  end

  defp format_config_attrs(%ProductGroupConfig{} = c) do
    pairs = [
      {"key", inspect(c.key)},
      {"name", inspect(c.name)},
      {"product", inspect(c.product)},
      {"transport_mode", inspect(c.transport_mode)},
      {"geography", inspect(c.geography)},
      {"product_patterns", inspect(c.product_patterns)},
      {"chain_magic", inspect(c.chain_magic)},
      {"chain_product_code", inspect(c.chain_product_code)},
      {"solver_binary", inspect(c.solver_binary)},
      {"signal_thresholds", inspect(c.signal_thresholds)},
      {"contract_term_map", inspect(c.contract_term_map)},
      {"location_anchors", inspect(c.location_anchors)},
      {"price_anchors", inspect(c.price_anchors)},
      {"default_poll_intervals", inspect(c.default_poll_intervals)},
      {"aliases", inspect(c.aliases)},
      {"active", inspect(c.active)}
    ]

    Enum.map_join(pairs, ",\n", fn {k, v} -> "#{k}: #{v}" end)
  end

  defp generate_variables(variables, pg) do
    if variables == [] do
      ""
    else
      entries = Enum.map_join(variables, ",\n", fn v ->
        "      #{inspect(format_variable(v))}"
      end)

      """
          for attrs <- [
      #{entries}
          ] do
            upsert_variable(Map.put(attrs, :product_group, "#{pg}"))
          end
      """
    end
  end

  defp format_variable(%VariableDefinition{} = v) do
    base = %{
      key: v.key,
      label: v.label,
      unit: v.unit || "",
      group_name: v.group_name,
      type: v.type,
      source_type: v.source_type,
      source_id: v.source_id,
      fetch_mode: v.fetch_mode,
      module_name: v.module_name,
      response_path: v.response_path,
      default_value: v.default_value,
      min_val: v.min_val,
      max_val: v.max_val,
      step: v.step,
      solver_position: v.solver_position,
      display_order: v.display_order,
      active: v.active,
      delta_threshold: v.delta_threshold,
      perturbation_stddev: v.perturbation_stddev,
      perturbation_min: v.perturbation_min,
      perturbation_max: v.perturbation_max,
      perturbation_flip_prob: v.perturbation_flip_prob
    }

    # Drop nil values for cleaner output
    base
    |> Enum.reject(fn {_k, v} -> is_nil(v) end)
    |> Map.new()
  end

  defp generate_routes(routes, pg) do
    if routes == [] do
      ""
    else
      entries = Enum.map_join(routes, ",\n", fn r ->
        "      #{inspect(format_route(r))}"
      end)

      """
          for attrs <- [
      #{entries}
          ] do
            upsert_route(Map.put(attrs, :product_group, "#{pg}"))
          end
      """
    end
  end

  defp format_route(%RouteDefinition{} = r) do
    %{
      key: r.key,
      name: r.name,
      origin: r.origin,
      destination: r.destination,
      distance: r.distance,
      distance_unit: r.distance_unit,
      transport_mode: r.transport_mode,
      freight_variable: r.freight_variable,
      buy_variable: r.buy_variable,
      sell_variable: r.sell_variable,
      typical_transit_days: r.typical_transit_days,
      transit_cost_per_day: r.transit_cost_per_day,
      unit_capacity: r.unit_capacity,
      display_order: r.display_order,
      active: r.active
    }
    |> Enum.reject(fn {_k, v} -> is_nil(v) end)
    |> Map.new()
  end

  defp generate_constraints(constraints, pg) do
    if constraints == [] do
      ""
    else
      entries = Enum.map_join(constraints, ",\n", fn c ->
        "      #{inspect(format_constraint(c))}"
      end)

      """
          for attrs <- [
      #{entries}
          ] do
            upsert_constraint(Map.put(attrs, :product_group, "#{pg}"))
          end
      """
    end
  end

  defp format_constraint(%ConstraintDefinition{} = c) do
    %{
      key: c.key,
      name: c.name,
      constraint_type: c.constraint_type,
      terminal: c.terminal,
      destination: c.destination,
      bound_variable: c.bound_variable,
      bound_min_variable: c.bound_min_variable,
      outage_variable: c.outage_variable,
      outage_factor: c.outage_factor,
      routes: c.routes,
      display_order: c.display_order,
      active: c.active
    }
    |> Enum.reject(fn {_k, v} -> is_nil(v) end)
    |> Map.new()
  end

  defp generate_upsert_helpers do
    """
      defp upsert_config(attrs) do
        %ProductGroupConfig{}
        |> ProductGroupConfig.changeset(attrs)
        |> Repo.insert(
          on_conflict: {:replace_all_except, [:id, :inserted_at]},
          conflict_target: [:key]
        )
      end

      defp upsert_variable(attrs) do
        %VariableDefinition{}
        |> VariableDefinition.changeset(attrs)
        |> Repo.insert(
          on_conflict: {:replace_all_except, [:id, :inserted_at]},
          conflict_target: [:product_group, :key]
        )
      end

      defp upsert_route(attrs) do
        %RouteDefinition{}
        |> RouteDefinition.changeset(attrs)
        |> Repo.insert(
          on_conflict: {:replace_all_except, [:id, :inserted_at]},
          conflict_target: [:product_group, :key]
        )
      end

      defp upsert_constraint(attrs) do
        %ConstraintDefinition{}
        |> ConstraintDefinition.changeset(attrs)
        |> Repo.insert(
          on_conflict: {:replace_all_except, [:id, :inserted_at]},
          conflict_target: [:product_group, :key]
        )
      end
    """
  end

  # ──────────────────────────────────────────────────────────
  # DB reads
  # ──────────────────────────────────────────────────────────

  defp load_variables(product_group) do
    Repo.all(
      from v in VariableDefinition,
        where: v.product_group == ^product_group and v.active == true,
        order_by: [asc: v.display_order, asc: v.key]
    )
  end

  defp load_routes(product_group) do
    Repo.all(
      from r in RouteDefinition,
        where: r.product_group == ^product_group and r.active == true,
        order_by: [asc: r.display_order, asc: r.key]
    )
  end

  defp load_constraints(product_group) do
    Repo.all(
      from c in ConstraintDefinition,
        where: c.product_group == ^product_group and c.active == true,
        order_by: [asc: c.display_order, asc: c.key]
    )
  end

  defp indent(text, spaces) do
    pad = String.duplicate(" ", spaces)
    text
    |> String.split("\n")
    |> Enum.map_join("\n", fn line ->
      if String.trim(line) == "", do: "", else: pad <> line
    end)
  end
end
